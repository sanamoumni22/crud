let crud = require('nbo-crud');
let acl = require('nbo-acl');
let pagination = require('./lib/pagination/index.js');
let events = require('events');

// Available lifecycle hooks
let oLifecycleHooks = {
  preLoad: null,
  postLoad: null,
  prePersist: null,
  postPersist: null,
  preUpdate: null,
  postUpdate: null,
  preDelete: null,
  postDelete: null
};
// Disable node js process max listeners limit
process.setMaxListeners(0);


// Normalizers
let normalizer_truncate = require('./lib/normalizers/truncate');

const DEFAULT_ROLE_USER = 'user';
const DEFAULT_ROLE_ADMIN = 'admin';

const DEFAULT_PRIMARY_KEY_NAME = 'id';
const DEFAULT_USER_FOREIGN_KEY_NAME = 'user_id';

let oErrorMessages = {
  forbidden: "Forbidden request.",
  missing_id: "Missing 'id' mandatory parameter to perform this action.",
  document_not_found: "No document found."
};

module.exports = function(router, auth, oApiConfiguration) {

  // Lifecycle hooks
  let EventEmitter = new events();
  EventEmitter.on("hooks", function(event, data, fCallback) {
    if (typeof oLifecycleHooks[String(event)] === 'undefined') {
      throw new Error("Not handled lifecycle hook event: " + String(event) + "\n");
    }

    if (oApiConfiguration.debug === true) {
      console.log('Lifecycle hook triggered: ' + String(event));
    }

    try {
      if (typeof oLifecycleHooks[String(event)] === 'function') {
        return fCallback( oLifecycleHooks[String(event)](data) );
      }
      return fCallback();
    } catch(e) {
      if (oApiConfiguration.debug === true) {
        console.log('Error on "' + String(event) + '" hook: ', e);
      }
      if (data.response.headersSent === false) {
        data.response.sendStatus(500);
        return data.response.send({error: JSON.stringify(e), code: 500});
      }
    }
  });

  let oApi = {

    aNormalizers : [
      { name: 'truncate', normalizer: normalizer_truncate }
    ],

    /**
     * GET
     *
     * @param req
     * @param res
     * @param done
     */
    get: function (req, res) {
      if (typeof req.query.id !== 'undefined') {
        return this.loadById(req, res);
      } else {
        return this.load(req, res);
      }
    },

    /**
     * POST
     *
     * @param req
     * @param res
     * @param done
     */
    post: function (req, res) {
      let sAction = 'POST',
        sEntity = this.getRequestedEndpoint(req, oApiConfiguration),
        oModel = this.loadModel(req.app, sEntity),
        sRequiredRole = ((typeof oApiConfiguration.entities[sEntity].role !== 'undefined')
          ? oApiConfiguration.entities[sEntity].role
          : DEFAULT_ROLE_USER
        ),
        oEntityConfiguration = oApiConfiguration.entities[sEntity];

      // Parse request and apply restriction if needed
      let crud = this.getCrudAdapter(),
        aAttrs = this.getFields(req.user, sEntity, req),
        oParameters = {};

      for (let i in aAttrs) {
        let sKey = aAttrs[i];
        // Systematically override user's foreign key value to avoid spoof
        if (sKey === oApi.getUserForeignKeyName(sEntity)) {
          oParameters[oApi.getUserForeignKeyName(sEntity)] = req.user[oApi.getPrimaryKeyName(sEntity)];
        } else if (typeof req.body[sKey] !== 'undefined') {
          let mValue = req.body[sKey];
          // Detect and parse JSON encoded data
          if (mValue.substr(0,1) === '{') {
            try {
              mValue = JSON.parse(mValue);
            } catch (e) {}
          }

          oParameters[sKey] = mValue;
        }
      }

      crud.create(oModel, oParameters).then(oResult => {
        // Pre persist hook
        EventEmitter.emit("hooks", "prePersist", { type: sEntity, request: req, response: res, data: oParameters }, function() {
          // Post persist hook
          EventEmitter.emit("hooks", "postPersist", { type: sEntity, request: req, response: res, data: oResult }, function() {
            return res.send({ data: oApi.normalizeEntity(req.user, sEntity, oResult, req) });
          });
        });
      }).catch(e => {
        console.log(e);
        if (! res.headersSent) {
          res.sendStatus(500);
          return res.send({error: JSON.stringify(e), code: 500});
        }
      });
    },

    /**
     * PUT
     * @todo this is a PATCH behavior rename this method
     *
     * @param req
     * @param res
     * @param done
     */
    put: function (req, res) {
      let sAction = 'PUT',
        sEntity = this.getRequestedEndpoint(req, oApiConfiguration),
        oModel = this.loadModel(req.app, sEntity),
        sRequiredRole = ((typeof oApiConfiguration.entities[sEntity].role !== 'undefined')
          ? oApiConfiguration.entities[sEntity].role
          : DEFAULT_ROLE_USER
      ),
      oEntityConfiguration = oApiConfiguration.entities[sEntity],
      bCheckAuth = (typeof oEntityConfiguration.user_restricted !== 'undefined' && oEntityConfiguration.user_restricted[sAction] === true);

      // Validate parameters
      if (typeof req.body.id === 'undefined') {
        res.sendStatus(404);
        return res.send({error: oErrorMessages.missing_id});
      }

      let crud = this.getCrudAdapter();
      crud.read(oModel, req.body.id).then(data => {
        if (! data) {
          res.sendStatus(404);
          return res.send({ error: oErrorMessages.document_not_found, code: 404 });
        }

        // Parse request and apply restriction if needed
        let crud = oApi.getCrudAdapter(),
        aAttrs = oApi.getFields(req.user, sEntity, req);

        // Check user restrictions
        if (bCheckAuth === true) {
          if (
            !acl.checkUserRestrictions(oApiConfiguration, req.user[oApi.getPrimaryKeyName(sEntity)], sAction, sEntity, data) &&
            !acl.hasRole(req.user, DEFAULT_ROLE_ADMIN)
          ) {
            res.sendStatus(403);
            return res.send({error: oErrorMessages.forbidden, code: 403});
          }
        }

        for (let i in aAttrs) {
          let sKey = aAttrs[i];
          if (sKey === oApi.getUserForeignKeyName(sEntity)) {
            data[oApi.getUserForeignKeyName(sEntity)] = req.user[oApi.getPrimaryKeyName(sEntity)];
          } else if (typeof req.body[sKey] !== 'undefined') {
            let mValue = req.body[sKey];
            // Detect and parse JSON encoded data
            if (mValue.substr(0,1) === '{') {
              try {
                mValue = JSON.parse(mValue);
              } catch (e) {}
            }

            data[sKey] = mValue;
          }
        }

        crud.update(data).then(oResult => {
          // Pre update hook
          EventEmitter.emit("hooks", "preUpdate", { type: sEntity, request: req, response: res, data: data }, function() {
            // Post update hook
            EventEmitter.emit("hooks", "postUpdate", {
              type: sEntity,
              request: req,
              response: res,
              data: oResult
            }, function () {
              return res.send({data: oApi.normalizeEntity(req.user, sEntity, oResult, req)});
            });
          });
        }).catch(e => {
          console.log(e);
          if (! res.headersSent) {
            res.sendStatus(500);
            return res.send({error: JSON.stringify(e), code: 500});
          }
        });
      }).catch(e => {
        console.log(e);
        if (! res.headersSent) {
          res.sendStatus(500);
          return res.send({error: JSON.stringify(e), code: 500});
        }
      });
    },

    /**
     * DELETE
     *
     * @param req
     * @param res
     * @param done
     */
    delete: function (req, res) {
      let sAction = 'DELETE',
        sEntity = this.getRequestedEndpoint(req, oApiConfiguration),
        oModel = this.loadModel(req.app, sEntity),
        sRequiredRole = (
          (typeof oApiConfiguration.entities[sEntity].role !== 'undefined')
            ? oApiConfiguration.entities[sEntity].role
            : DEFAULT_ROLE_USER
        ),
        oEntityConfiguration = oApiConfiguration.entities[sEntity],
        bCheckAuth = (typeof oEntityConfiguration.user_restricted !== 'undefined' && oEntityConfiguration.user_restricted[sAction] === true);

      // Validate parameters
      if (typeof req.body.id === 'undefined') {
        res.sendStatus(403);
        return res.send({error: oErrorMessages.missing_id});
      }

      let crud = this.getCrudAdapter();
      crud.read(oModel, req.body.id).then(data => {
        if (! data) {
          res.sendStatus(404);
          return res.send({ error: oErrorMessages.document_not_found, code: 404 });
        }

        // Check user restrictions
        if (bCheckAuth === true) {
          if (
            ! acl.checkUserRestrictions(oApiConfiguration, req.user[oApi.getPrimaryKeyName(sEntity)], sAction, sEntity, data) &&
            ! acl.hasRole(req.user, DEFAULT_ROLE_ADMIN)
          ) {
            res.sendStatus(403);
            return res.send({error: oErrorMessages.forbidden, code: 403});
          }
        }
        crud.delete(data).then(oResult => {
          // Pre delete hook
          EventEmitter.emit("hooks", "preDelete", { type: sEntity, request: req, response: res, data: data }, function() {
            // Post delete hook
            EventEmitter.emit("hooks", "postDelete", { type: sEntity, request: req, response: res, data: oResult }, function() {
              return res.send( { deleted: true, data: oApi.normalizeEntity(req.user, sEntity, oResult, req) });
            });
          });
        }).catch(e => {
          console.log(e);
          if (! res.headersSent) {
            res.sendStatus(500);
            return res.send({error: JSON.stringify(e), code: 500});
          }
        });
      }).catch(e => {
        console.log(e);
        if (! res.headersSent) {
          res.sendStatus(500);
          return res.send({error: JSON.stringify(e), code: 500});
        }
      });

    },

    loadById: function(req, res) {
      let sAction = 'GET',
      sEntity = this.getRequestedEndpoint(req, oApiConfiguration),
      oModel = this.loadModel(req.app, sEntity),
      sRequiredRole = ((typeof oApiConfiguration.entities[sEntity].role !== 'undefined')
        ? oApiConfiguration.entities[sEntity].role
        : DEFAULT_ROLE_USER
      ),
      oEntityConfiguration = oApiConfiguration.entities[sEntity],
      bCheckAuth = (typeof oEntityConfiguration.user_restricted !== 'undefined' && oEntityConfiguration.user_restricted[sAction] === true);
      let crud = this.getCrudAdapter();

      // Read with a given id
      crud.read(oModel, req.query.id).then(oResult => {

        if (! oResult) {
          res.sendStatus(404);
          return res.send({error: oErrorMessages.document_not_found, code: 404});
        }

        // Pre load hook
        EventEmitter.emit("hooks", "preLoad", { type: sEntity, request: req, response: res, data: req.query.id }, function() {

          if (bCheckAuth === true) {
            // Check user restrictions
            if (
              typeof req.user === 'object' &&
              typeof req.user[oApi.getPrimaryKeyName(sEntity)] !== 'undefined' &&
              ! acl.checkUserRestrictions(oApiConfiguration, req.user[oApi.getPrimaryKeyName(sEntity)], sAction, sEntity, oResult) &&
              ! acl.hasRole(req.user, DEFAULT_ROLE_ADMIN)
            ) {
              return res.send({error: oErrorMessages.forbidden, code: 403});
            }
          }

          // Post load hook
          EventEmitter.emit("hooks", "postLoad", { type: sEntity, request: req, response: res, data: oResult }, function() {
            let oResponse = { data: oApi.normalizeEntity(req.user, sEntity, oResult, req) };
            if (typeof req.query.export !== 'undefined') {
              return oApi.download(oResponse, req, res);
            }
            return res.send(oResponse);
          });
        });
      }).catch(e => {
        console.log(e);
        if (! res.headersSent) {
          res.status(500);
          return res.send({error: JSON.stringify(e), code: 500});
        }
      });
    },

    load: function(req, res) {
      let sAction = 'GET',
      sEntity = this.getRequestedEndpoint(req, oApiConfiguration),
      oModel = this.loadModel(req.app, sEntity),
      sRequiredRole = ((typeof oApiConfiguration.entities[sEntity].role !== 'undefined')
        ? oApiConfiguration.entities[sEntity].role
        : DEFAULT_ROLE_USER
      ),
      oEntityConfiguration = oApiConfiguration.entities[sEntity],
      bCheckAuth = (typeof oEntityConfiguration.user_restricted !== 'undefined' && oEntityConfiguration.user_restricted[sAction] === true);
      let crud = this.getCrudAdapter();

      // Restrict query to user scope if needed
      let oQuery = {};
      if (
        bCheckAuth === true &&
        oEntityConfiguration.user_restricted[sAction] === true &&
        acl.hasRole(req.user, DEFAULT_ROLE_ADMIN) === false
      ) {
        // Protected endpoint without authenticated user
        if (typeof req.user === 'undefined') {
          res.status(401);
          return res.send({error: 'Forbidden request.', code: 401});
        }
        oQuery[oApi.getUserForeignKeyName(sEntity)] = "" + req.user[oApi.getPrimaryKeyName(sEntity)];
      }

      aFields = (
      (oApiConfiguration[sEntity] && oApiConfiguration[sEntity].fields && oApiConfiguration[sEntity].fields.length !== 0)
        ? oApiConfiguration[sEntity].fields
        : this.getFields(req.user, sEntity, req)
      );

      // Parse query params
      this.parseRequestParameters(req.query, aFields , oQuery);

      // Parse pagination
      let oPagination = pagination();
      oPagination.limit = (parseInt(req.query.limit) || oApiConfiguration.limit);
      oPagination.page = (parseInt(req.query.page) || 1);
      oPagination.offset = ((oPagination.page > 1) ? ((oPagination.page-1) * oPagination.limit) : 0);

      // Sort
      let aSortParams = [];
      if (req.query.sort) {
        aSortParams = JSON.parse(req.query.sort);
      }

      let oPromise = crud.query(oModel, oQuery, oPagination, aSortParams);
      if (typeof req.query.count !== 'undefined') {
        oPromise = crud.count(oModel, oQuery, oPagination, aSortParams);
      }

      oPromise.then(mResult => {
        // Pre load hook
        EventEmitter.emit("hooks", "preLoad", { type: sEntity, request: req, response: res, data: oQuery }, function() {
          // Handle count queries
          if (typeof req.query.count !== 'undefined') {
            return res.send({ count: mResult });
          }

          let aResponse = [];
          let aData = (typeof mResult.data !== 'undefined') ? mResult.data : mResult;


          for (let i in aData) {
            let oEntityConfig = oEntityConfiguration,
            oDoc = aData[i];

            // Check user restrictions
            if (bCheckAuth === true) {
              if (
                typeof req.user === 'object' &&
                typeof req.user[oApi.getPrimaryKeyName(sEntity)] !== 'undefined' &&
                ! acl.checkUserRestrictions(oApiConfiguration, req.user[oApi.getPrimaryKeyName(sEntity)], sAction, sEntity, oDoc) &&
                ! acl.hasRole(req.user, DEFAULT_ROLE_ADMIN)
              ) {
                return res.send({error: oErrorMessages.forbidden, code: 403});
              }
            }

            // Apply normalizers on fields if needed
            if (oEntityConfig.normalize && oEntityConfig.normalize.length !== 0) {
              for (let i in oEntityConfig.normalize) {
                let oNormalize = oEntityConfig.normalize[i],
                sNormalizer = oNormalize.normalizer,
                oNormalizer = oApi.getNormalizer(sNormalizer);

                if (oNormalizer == null) {
                  // @todo normalizer not found log this kind of event
                  continue;
                }

                let sFieldName = oNormalize.field,
                oSettings = null;

                if (typeof oNormalize.settings !== 'undefined') {
                  oSettings = oNormalize.settings;
                }

                if (oDoc[sFieldName]) {
                  oDoc[sFieldName] = oNormalizer.normalize(oDoc[sFieldName], oSettings);
                }
              }
            }

            aResponse.push(oApi.normalizeEntity(req.user, sEntity, oDoc, req));
          }

          // Post load hook
          EventEmitter.emit("hooks", "postLoad", { type: sEntity, request: req, response: res, data: mResult }, function () {
            let oResponse = {
              data: aResponse,
              meta: {
                page: iPage = (parseInt(req.query.page) || 1),
                count: aResponse.length
              }
            };

            if (typeof req.query.export !== 'undefined') {
              return oApi.download(oResponse, req, res);
            }
            return res.send(oResponse);
          });
        });
      }).catch(e => {
        if (! res.headersSent) {
          res.status(500);
          return res.send({error: JSON.stringify(e), code: 500});
        }
      });
    },

    /**
     * Register a lifecycle hook
     *
     * @param sHookName
     * @param fCallback
     * @returns {boolean}
     */
    registerHook: function(sHookName, fCallback) {
      if (typeof oLifecycleHooks[sHookName] === 'undefined' || typeof fCallback !== 'function') {
        return false;
      }

      oLifecycleHooks[sHookName] = fCallback;
      return (oLifecycleHooks[sHookName] === fCallback);
    },

    /**
     * Inject an entity model
     *
     * @param oAppContext
     * @param sEntityName
     * @returns {*}
     * @private
     */
    loadModel: function(oAppContext, sEntityName) {
      return require(oAppContext.get('root-path') + '/models/' + sEntityName);
    },

    /**
     * Retrieve mongoose entity fields overrided by configuration scope if any
     *
     * @param oUser
     * @param sEntityType
     * @param req
     * @returns {*|Array}
     */
    getFields: function (oUser, sEntityType, req) {

      let aFields = [],
        sEntityName = sEntityType.toLowerCase(),
        bIsAdmin = acl.hasRole(oUser, 'admin');

      // If restricted fields scope from api configuration and the user has not the "admin" role
      if (typeof oApiConfiguration.entities[sEntityName].fields !== 'undefined' && bIsAdmin === false) {
        // Use restricted fields scope
        aFields = oApiConfiguration.entities[sEntityName].fields;
      } else {
        // Retrieve all entity fields
        aFields = this.getCrudAdapter().getFields(this.loadModel(req.app, sEntityType));
      }

      return aFields;
    },

    /**
     * @param sEntity
     * @returns string
     */
    getPrimaryKeyName: function(sEntity) {
      if (typeof oApiConfiguration.entities[sEntity].primary_key_name !== 'undefined') {
        return oApiConfiguration.entities[sEntity].primary_key_name;
      }
      return DEFAULT_PRIMARY_KEY_NAME;
    },

    /**
     * @param sEntity
     * @returns string
     */
    getUserForeignKeyName: function(sEntity) {
      if (typeof oApiConfiguration.entities[sEntity].user_foreign_key_name !== 'undefined') {
        return oApiConfiguration.entities[sEntity].user_foreign_key_name;
      }
      return DEFAULT_USER_FOREIGN_KEY_NAME;
    },

    getDefaultLimit: function() {
      return oApiConfiguration.limit;
    },

    /**
     * Apply a mask to a mongoose entity object
     *
     * @param oUser
     * @param sType
     * @param oDocument
     * @param req
     */
    normalizeEntity: function (oUser, sType, oDocument, req) {
      let oOutput = {},
      aScope = this.getFields(oUser, sType, req);

      for (let key in aScope) {

        // Handle sub objects "foo.bar"
        if (aScope[key].indexOf('.') !== -1) {
          aScope[key] = aScope[key].split('.')[0]
        }

        if (typeof oDocument[aScope[key]] !== 'undefined') {
          oOutput[aScope[key]] = oDocument[aScope[key]];
        }
      }
      return oOutput;
    },

    /**
     *
     * @param sNormalizerName
     * @returns {*}
     */
    getNormalizer: function(sNormalizerName) {
      for (let i in this.aNormalizers) {
        let oNormalizer = this.aNormalizers[i];
        if (oNormalizer.name === sNormalizerName) {
          return oNormalizer.normalizer;
        }
      }
      return null;
    },

    /**
     *
     * @param oQueryString
     * @param aScope
     * @param oOutput
     * @private
     */
    parseRequestParameters: function(oQueryString, aScope, oOutput) {
      if (! oOutput) {
        let oOutput = {};
      }

      let oFilterQuery = {};
      if (typeof oQueryString.q === 'string') {
        oFilterQuery = JSON.parse(oQueryString.q);
      }

      for (let i in aScope) {
        let sAttribute = aScope[i];

        if (typeof oQueryString[sAttribute] === 'undefined' && typeof oFilterQuery[sAttribute] === 'undefined') {
          continue;
        }

        if (typeof oQueryString[sAttribute] !== 'undefined') {
          oOutput[sAttribute] = oQueryString[sAttribute];
        } else if (typeof oFilterQuery[sAttribute] !== 'undefined') {
          oOutput[sAttribute] = oFilterQuery[sAttribute];
        }
      }
    },

    /**
     * Compute requested endpoint
     *
     * @param req
     * @param oApiConfiguration
     * @returns {string}
     * @private
     */
    getRequestedEndpoint: function (req, oApiConfiguration) {
      return req.originalUrl.substr(oApiConfiguration.uri.length).split('?')[0].replace('/', '');
    },

    /**
     * Load configured CRUD adapter
     *
     * @returns {*}
     */
    getCrudAdapter: function () {
      return new crud(oApiConfiguration);
    },

    /**
     * Data export as JSON default format
     *
     * @param oResponse
     * @param req
     * @param res
     */
    download: function (oResponse, req, res) {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition','attachment; filename=extract.json');
      res.send(JSON.stringify(oResponse), null, 2);
    }

  }, aEndpoints = [];

  // Compute available REST api endpoints from entities scope on configuration
  for (sEntity in oApiConfiguration.entities) {
    aEndpoints.push('/' + oApiConfiguration.entities[sEntity].endpoint);
  }

  let checkAuthentication = function (req, res, done) {
    let sResource = oApi.getRequestedEndpoint(req, oApiConfiguration);
    let sAction = req.method;
    if (typeof oApiConfiguration.entities[sResource].user_restricted !== 'undefined' && oApiConfiguration.entities[sResource].user_restricted[sAction] === true) {
      console.log('Authentication required.');
      // Auth required on this endpoint for this action
      return auth.isLoggedIn(req, res, done);
    } else {
      console.log('No authentication required.');
      return done();
    }
  };

  router.all(aEndpoints, function(req, res, done) {

    // Check authentication if required
    checkAuthentication(req, res, function (err, oUser) {
      // Assign authenticated user to the request
      if (oUser) {
        req.user = oUser;
      }

      // Bind all needed HTTP verb to scaffold REST endpoints for each resource
      switch(req.method.toLowerCase()) {
        case 'get':
          return oApi.get(req, res);
        case 'post':
          return oApi.post(req, res);
        case 'put':
          return oApi.put(req, res);
        case 'patch':
          return oApi.patch(req, res); // @todo PATCH
        case 'delete':
          return oApi.delete(req, res);
        default:
          res.status(500);
          return res.send({error: "Not supported request."});
      }
    });

  });

  return oApi;
};



