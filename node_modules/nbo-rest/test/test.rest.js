let assert = require('assert');

module.exports = function(oRest, sDriver, sDatabaseType, oRequest, oModel, sModelName) {
  let aGarbage = [],
    oRecord = {},
    oOtherUserRecord = {},
    oResponse = {
      sendStatus: function(iCode) {},
      setContentType: function(sType) {}
    };

  oResponse.setHeader = function() {};

  describe('Test REST component with ' + sDriver + ' driver and ' + sDatabaseType + ' database.', function () {
    oRequest.originalUrl = '/' + sModelName;

    it('Has all required methods', function () {
        return new Promise(resolve => {
            assert.strictEqual(typeof oRest.get, 'function', 'GET endpoint not found.');
            assert.strictEqual(typeof oRest.post, 'function', 'POST endpoint not found.');
            assert.strictEqual(typeof oRest.put, 'function', 'PUT endpoint not found.');
            assert.strictEqual(typeof oRest.delete, 'function', 'DELETE endpoint not found.');
            assert.strictEqual(typeof oRest.getCrudAdapter, 'function', 'getCrudAdapter() method not found.');
            assert.strictEqual(typeof oRest.getRequestedEndpoint, 'function', 'getRequestedEndpoint() not found.');
            assert.strictEqual(typeof oRest.getPrimaryKeyName, 'function', 'getPrimaryKeyName() not found.');
            assert.strictEqual(typeof oRest.getUserForeignKeyName, 'function', 'getUserForeignKeyName() not found.');
            resolve();
        });
    });

    it('POST endpoint to create a user record.', function() {
        return new Promise(resolve => {
            oRequest.query = {};
            oRequest.body.content = 'Hello REST!';
            oResponse.send = function(oResult) {
                assert.strictEqual(oResult.data.content, 'Hello REST!');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');

                oRecord = oResult.data;
                resolve();
            };

            // Test Lifecycle pre/post persist hook events are triggered
            let aTestedHooks = ['prePersist', 'postPersist'];
            for (let i in aTestedHooks) {
              sHook = aTestedHooks[i];
              oRest.registerHook(sHook, function(oEvent) {
                assert.strictEqual(oEvent.type, sModelName, 'Invalid "' + sHook + '" event type: ' + oEvent.type + '.');
                assert.strictEqual(typeof oEvent.data !== 'undefined', true, 'No data provided by the hook' + sHook);
                assert.strictEqual(typeof oEvent.request !== 'undefined', true, 'No request provided by the hook' + sHook);
                assert.strictEqual(typeof oEvent.response !== 'undefined', true, 'No response provided by the hook' + sHook);

              });
            }

            oRest.post(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('POST endpoint to create an another user record.', function() {
        return new Promise(resolve => {
            oRequest.body.content = 'Hello REST from an another user!';
            oRequest.user[oRest.getPrimaryKeyName(sModelName)] = 999;
            oResponse.send = function(oResult) {
                aGarbage.push(oResult.data);
                assert.strictEqual(oResult.data.content, 'Hello REST from an another user!');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');
                oOtherUserRecord = oResult.data;

                resolve();
            };
            oRest.post(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('POST to edit restricted fields scope.', function() {
        return new Promise(resolve => {
            oRequest.body.content = 'Hello REST from an another user to test fields restriction!';
            oRequest.body.done = true;
            oRequest.user[oRest.getPrimaryKeyName(sModelName)] = 666;
            oResponse.send = function(oResult) {
                aGarbage.push(oResult.data);
                assert.strictEqual(oResult.data.content, 'Hello REST from an another user to test fields restriction!');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');
                oOtherUserRecord = oResult.data;

                resolve();
            };
            oRest.post(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('Unable to spoof identity with a POST request and "user_restricted" option.', function() {
        return new Promise(resolve => {
            oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oOtherUserRecord[oRest.getUserForeignKeyName(sModelName)];
            oRequest.body.content = 'Hello REST from a spoofed user!';
            oRequest.body[oRest.getUserForeignKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)];
            oResponse.send = function(oResult) {
                aGarbage.push(oResult.data);
                assert.strictEqual(oResult.data[oRest.getUserForeignKeyName(sModelName)], oOtherUserRecord[oRest.getUserForeignKeyName(sModelName)], 'Able to spoof identity.');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');
                oOtherUserRecord = oResult.data;

                resolve();
            };
            oRest.post(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('GET endpoint (to list, no id and query provided)', function() {
        return new Promise(resolve => {
          oResponse.send = function(oResult) {
            assert.strictEqual(oResult.data.length, 2, 'Should be only 2 records for this user.');
            assert.strictEqual(oResult.meta.count, 2, 'Invalid meta count.');
            for (var i in oResult.data) {
              // Assert that all record are mine
              assert.strictEqual(oResult.data[i][oRest.getUserForeignKeyName(sModelName)].toString(), oRequest.user[oRest.getPrimaryKeyName(sModelName)].toString(), 'Some records are from an another user.');
              // Assert that no restricted fields are found
              assert.strictEqual(oResult.data[i].done, undefined, 'Restricted field found.');
            }
            resolve();
          };

          // Test Lifecycle pre/post load hook events are triggered
          let aTestedHooks = ['preLoad', 'postLoad'];
          for (let i in aTestedHooks) {
            sHook = aTestedHooks[i];
            oRest.registerHook(sHook, function(oEvent) {
              assert.strictEqual(oEvent.type, sModelName, 'Invalid "' + sHook + '" event type: ' + oEvent.type + '.');
              assert.strictEqual(typeof oEvent.data !== 'undefined', true, 'No data provided by the hook' + sHook);
              assert.strictEqual(typeof oEvent.request !== 'undefined', true, 'No request provided by the hook' + sHook);
              assert.strictEqual(typeof oEvent.response !== 'undefined', true, 'No response provided by the hook' + sHook);

            });
          }

          oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('GET endpoint with export query parameter (to download dataset in default JSON format)', function() {
      return new Promise(resolve => {
        oResponse.send = function(oData) {
          assert.strictEqual('string', typeof oData, 'Downloaded response type must be string.');
          assert.strictEqual('object', typeof JSON.parse(oData), 'Unable to parse dowloaded JSON data representation.');

          // Delete from request for next test
          delete oExportReq.query.export
          resolve();
        };

        let oExportReq = Object.assign(oRequest)
        oExportReq.query.export = 1
        oRest.get(oExportReq, oResponse);
      }).catch((e) => {
        console.log(e);
      });
    });

    it('GET endpoint to count query total results.', function() {
      oRequest.query.count = true;
      return new Promise(resolve => {

        // Delete export query parameter
        delete oRequest.query.export;

        oResponse.send = function(oResult) {
          assert.strictEqual(oResult.count, 2, 'Invalid data rows count.');

          // Delete from request for next test
          delete oRequest.query.count;

          resolve();
        };

        oResponse.count = true;

        oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
      });
    });

    it('GET endpoint (to query data by attribute value)', function() {
        return new Promise(resolve => {
          // Remove count parameter from query string
          delete oRequest.query.count;

          oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)];
          oRequest.query.q = JSON.stringify({ content: oRecord.content });

          oResponse.send = function(oResult) {
            assert.strictEqual(oResult.data.length, 1, 'Should be only 1 records for this query.');
            assert.strictEqual(oResult.meta.count, 1, 'Invalid meta count.');
            for (var i in oResult.data) {
              assert.strictEqual(oResult.data[i].content, oRecord.content, 'Unable to query by value.');
            }
            resolve();
          };
          oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('GET endpoint (to perform text search with regular expressions)', function() {
        return new Promise(resolve => {
          oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)];
          oRequest.query.q = JSON.stringify({ content: { '$regex': 'REST' } });

          oResponse.send = function(oResult) {
            assert.strictEqual(oResult.data.length, 1, 'Should be only 1 records for this query.');
            assert.strictEqual(oResult.meta.count, 1, 'Invalid meta count.');
            for (var i in oResult.data) {
              assert.strictEqual(oResult.data[i].content, oRecord.content, 'Unable to query by value.');
            }
            resolve();
          };
          oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('GET endpoint with no results (to perform text search with regular expressions)', function() {
        return new Promise(resolve => {
          oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)];
          oRequest.query.q = JSON.stringify({ content: { '$regex': 'alkpote' } });

          oResponse.send = function(oResult) {
            assert.strictEqual(oResult.data.length, 0, 'Should be only 0 records for this query.');
            assert.strictEqual(oResult.meta.count, 0, 'Invalid meta count.');
            resolve();
          };
          oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('GET endpoint', function() {
        return new Promise(resolve => {
            delete oRequest.query.export;

            oRequest.query.id = oRecord[oRest.getPrimaryKeyName(sModelName)].toString();
            oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)].toString();
            oResponse.send = function(oResult) {
                assert.strictEqual(oResult.data.content, 'Hello REST!', 'Unable to retrieve created record via GET.');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');

                resolve();
            };
            oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('Unable to GET a document from an another user with "user_restricted" option.', function() {
      return new Promise(resolve => {
        oRequest.query.id = oOtherUserRecord[oRest.getPrimaryKeyName(sModelName)].toString();
        oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)].toString();
        oResponse.send = function(oResult) {
          assert.strictEqual(oResult.code, 403, 'Able to read other users document with "user_restricted" option.');
          resolve();
        };
        oRest.get(oRequest, oResponse, { isLoggedIn: () => {} });
      });
    });

    it('PUT endpoint', function() {
      return new Promise(resolve => {
        oRequest.body.id = oRecord[oRest.getPrimaryKeyName(sModelName)].toString();
        oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)].toString();
        oRequest.body.content = 'Hello REST! [UPDATED]';
        oResponse.send = function(oResult) {
          assert.strictEqual(oResult.data.content, 'Hello REST! [UPDATED]', 'Unable to update created record via PUT.');
          assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');

          resolve();
        };

        // Test Lifecycle pre/post update hook events are triggered
        let aTestedHooks = ['preUpdate', 'postUpdate'];
        for (let i in aTestedHooks) {
          sHook = aTestedHooks[i];
          oRest.registerHook(sHook, function(oEvent) {
            assert.strictEqual(oEvent.type, sModelName, 'Invalid "' + sHook + '" event type: ' + oEvent.type + '.');
            assert.strictEqual(typeof oEvent.data !== 'undefined', true, 'No data provided by the hook' + sHook);
            assert.strictEqual(typeof oEvent.request !== 'undefined', true, 'No request provided by the hook' + sHook);
            assert.strictEqual(typeof oEvent.response !== 'undefined', true, 'No response provided by the hook' + sHook);

          });
        }

        oRest.put(oRequest, oResponse, { isLoggedIn: () => {} });
      });
    });

    it('Unable to spoof identity with a PUT request and "user_restricted" option.', function() {
        return new Promise(resolve => {
          oRequest.body.id = oRecord[oRest.getPrimaryKeyName(sModelName)].toString();
          oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oOtherUserRecord[oRest.getUserForeignKeyName(sModelName)].toString();
          oRequest.body.content = 'Hello REST! [UPDATED]';
          oResponse.send = function(oResult) {
            assert.strictEqual(oResult.code, 403, 'Able to update other users document with "user_restricted" option.');
            resolve();
          };
          oRest.put(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('Unable to edit restricted fields with PUT request.', function() {
        return new Promise(resolve => {
            oRequest.body.id = oRecord[oRest.getPrimaryKeyName(sModelName)].toString();
            oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)].toString();
            oRequest.body.content = 'Hello REST! [UPDATED]';
            oRequest.body.done = true;
            oResponse.send = function(oResult) {
                assert.strictEqual(oResult.data.content, 'Hello REST! [UPDATED]', 'Update failed.');
                assert.strictEqual(oResult.data.done, undefined, 'Restricted field found.');
                resolve();
            };
            oRest.put(oRequest, oResponse, { isLoggedIn: () => {} });
        });
    });

    it('DELETE endpoint', function() {
      return new Promise(resolve => {
        oRequest.body.id = oRecord[oRest.getPrimaryKeyName(sModelName)].toString();
        oResponse.send = function(oResult) {
          assert.strictEqual(oResult.deleted, true, 'Unable to delete created record via DELETE.');
          resolve();
        };

        // Test Lifecycle pre/post load hook events are triggered
        let aTestedHooks = ['preDelete', 'postDelete'];
        for (let i in aTestedHooks) {
          sHook = aTestedHooks[i];
          oRest.registerHook(sHook, function(oEvent) {
            assert.strictEqual(oEvent.type, sModelName, 'Invalid "' + sHook + '" event type: ' + oEvent.type + '.');
            assert.strictEqual(typeof oEvent.data !== 'undefined', true, 'No data provided by the hook' + sHook);
            assert.strictEqual(typeof oEvent.request !== 'undefined', true, 'No request provided by the hook' + sHook);
            assert.strictEqual(typeof oEvent.response !== 'undefined', true, 'No response provided by the hook' + sHook);

          });
        }

        oRest.delete(oRequest, oResponse, { isLoggedIn: () => {} });
      });
    });

    it('Unable to DELETE a document from an another user with "user_restricted" option.', function() {
      return new Promise(resolve => {
        oRequest.body.id = oOtherUserRecord[oRest.getPrimaryKeyName(sModelName)].toString();
        oRequest.user[oRest.getPrimaryKeyName(sModelName)] = oRecord[oRest.getUserForeignKeyName(sModelName)].toString();
        oResponse.send = function(oResult) {
          assert.strictEqual(oResult.code, 403, 'Able to delete other users document with "user_restricted" option.');
          resolve();
        };
        oRest.delete(oRequest, oResponse, { isLoggedIn: () => {} });
      })
    });

    // Clean created records
    after(function() {
      return new Promise(resolve => {
        oResponse.send = function (oResult) {};

        for (let i in aGarbage) {
          oRequest.body.id = aGarbage[i][oRest.getPrimaryKeyName(sModelName)].toString();
          oRequest.user[oRest.getPrimaryKeyName(sModelName)] = aGarbage[i][oRest.getUserForeignKeyName(sModelName)].toString();
          oRequest.user.roles = [{name: 'admin'}];
          oResponse.send = function(oResponse) {};

          oRest.delete(oRequest, oResponse, { isLoggedIn: () => {} });
          if (parseInt(i) === aGarbage.length - 1) {
            resolve();
          }
        }
      });
    });

  });
};
